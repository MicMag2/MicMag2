#include "multiscale.h"
#include <math.h>
#include <iostream>


double fms(double x, double y, double z)
{
    double R = sqrt(x*x+y*y+z*z);
    return -atan((y*z)/(R*x));
}

double gms(double x, double y, double z)
{
    double R = sqrt(x*x+y*y+z*z);
    return atanh(x/R);
}

double Hhb(double x, double y, double z, double Lx, double Ly, double Lz, double Mx, double My, double Mz)
{ 
    double Hx = 0;
//    Hy = 0;
//    Hz = 0;
    
    for (int k = -1; k <= 1; k += 2)
        for (int j = -1; j <= 1; j += 2)
            for (int i = -1; i <= 1; i += 2)
            {
                Hx += i*j*k*fms(x+i*0.5*Lx, y+j*0.5*Ly, z+k*0.5*Lz)*Mx;
//                Hy += i*j*k*gms(z+i*0.5*Lz, x+j*0.5*Lx, y+k*0.5*Ly)*Mx;
//                Hz += i*j*k*gms(y+i*0.5*Ly, z+j*0.5*Lz, x+k*0.5*Lx)*Mx;

                Hx += i*j*k*gms(z+i*0.5*Lz, x+j*0.5*Lx, y+k*0.5*Ly)*My;
//                Hy += i*j*k*fms(y+i*0.5*Ly, z+j*0.5*Lz, x+k*0.5*Lx)*My;
//                Hz += i*j*k*gms(x+i*0.5*Lx, y+j*0.5*Ly, z+k*0.5*Lz)*My;

                Hx += i*j*k*gms(y+i*0.5*Ly, z+j*0.5*Lz, x+k*0.5*Lx)*Mz;
//                Hy += i*j*k*gms(x+i*0.5*Lx, y+j*0.5*Ly, z+k*0.5*Lz)*Mz;
//                Hz += i*j*k*fms(z+i*0.5*Lz, x+j*0.5*Lx, y+k*0.5*Ly)*Mz;
            }

    double pi = acos(-1);
    Hx /= 4*pi;
//    Hy /= 4*pi;
//    Hz /= 4*pi;
	return Hx;
}

double Hmm(double x, double y, double z, double Lx, double Ly, double Lz, double mx, double my, double mz)
{
    double Hx = 0;
//    Hy = 0;
//    Hz = 0;
    
    for (int k = -1; k <= 1; k += 2)
        for (int j = -1; j <= 1; j += 2)
            for (int i = -1; i <= 1; i += 2)
            {
                Hx += i*j*k*fms(x+i*0.5*Lx, y+j*0.5*Ly, z+k*0.5*Lz)*mx;
//                Hy += i*j*k*gms(z+i*0.5*Lz, x+j*0.5*Lx, y+k*0.5*Ly)*mx;
//                Hz += i*j*k*gms(y+i*0.5*Ly, z+j*0.5*Lz, x+k*0.5*Lx)*mx;

                Hx += i*j*k*gms(z+i*0.5*Lz, x+j*0.5*Lx, y+k*0.5*Ly)*my;
//                Hy += i*j*k*fms(y+i*0.5*Ly, z+j*0.5*Lz, x+k*0.5*Lx)*my;
//                Hz += i*j*k*gms(x+i*0.5*Lx, y+j*0.5*Ly, z+k*0.5*Lz)*my;

                Hx += i*j*k*gms(y+i*0.5*Ly, z+j*0.5*Lz, x+k*0.5*Lx)*mz;
//                Hy += i*j*k*gms(x+i*0.5*Lx, y+j*0.5*Ly, z+k*0.5*Lz)*mz;
//                Hz += i*j*k*fms(z+i*0.5*Lz, x+j*0.5*Lx, y+k*0.5*Ly)*mz;
            }

    double pi = acos(-1);
    Hx /= 4*pi*Lx*Ly*Lz;
//    Hy /= 4*pi*Lx*Ly*Lz;
//    Hz /= 4*pi*Lx*Ly*Lz;
    
	return Hx;
}

// xyz = position of spin vs cell (in metres)
// Lxyz = cellsize
// M = magnetization, m = spin
// only use (M) for the field generated by cells closest to the interface
// only use (m) for the field applied on the cells closest to the interface

/*int main()
{
// position of the hb spin with respect to the center of the mm cell
    double x = 1;
    double y = 1;
    double z = 0;
    double R = sqrt(x*x+y*y+z*z);

// size of the mm cell
    double Lx = 1;
    double Ly = 1;
    double Lz = 1;

// magnetization in the mm cell
    double Mx = 1;
    double My = 0;
    double Mz = 1;

// magnetic moment of the hb spin
    double mx = 1;
    double my = 1;
    double mz = 0;

// magnetic field
    double Hx, Hy, Hz;

    double pi = acos(-1);

// field at the hb spin
    Hhb(x, y, z, Lx, Ly, Lz, Mx, My, Mz, Hx, Hy, Hz);
    std::cout << Hx << " " << Hy << " " << Hz << "\n";

// field from dipole
    std::cout << (-Mx*pow(R, 2)+3*(Mx*x+My*y+Mz*z)*x)/(4*pi*pow(R, 5)) << " " << (-My*pow(R, 2)+3*(Mx*x+My*y+Mz*z)*y)/(4*pi*pow(R, 5)) << " " << (-Mz*pow(R, 2)+3*(Mx*x+My*y+Mz*z)*z)/(4*pi*pow(R, 5)) << "\n";

// field in the mm cell
    Hmm(x, y, z, Lx, Ly, Lz, mx, my, mz, Hx, Hy, Hz);
    std::cout << Hx << " " << Hy << " " << Hz << "\n";

// field from dipole
    std::cout << (-mx*pow(R, 2)+3*(mx*x+my*y+mz*z)*x)/(4*pi*pow(R, 5)) << " " << (-my*pow(R, 2)+3*(mx*x+my*y+mz*z)*y)/(4*pi*pow(R, 5)) << " " << (-mz*pow(R, 2)+3*(mx*x+my*y+mz*z)*z)/(4*pi*pow(R, 5)) << "\n";
}*/
