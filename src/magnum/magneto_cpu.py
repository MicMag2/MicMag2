# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _magneto_cpu
else:
    import _magneto_cpu

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _magneto_cpu.SWIG_PyInstanceMethod_New
_swig_new_static_method = _magneto_cpu.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _magneto_cpu.delete_SwigPyIterator
    value = _swig_new_instance_method(_magneto_cpu.SwigPyIterator_value)
    incr = _swig_new_instance_method(_magneto_cpu.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_magneto_cpu.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_magneto_cpu.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_magneto_cpu.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_magneto_cpu.SwigPyIterator_copy)
    next = _swig_new_instance_method(_magneto_cpu.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_magneto_cpu.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_magneto_cpu.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_magneto_cpu.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_magneto_cpu.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_magneto_cpu.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_magneto_cpu.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_magneto_cpu.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_magneto_cpu.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_magneto_cpu.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _magneto_cpu:
_magneto_cpu.SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_magneto_cpu.StringVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_magneto_cpu.StringVector___nonzero__)
    __bool__ = _swig_new_instance_method(_magneto_cpu.StringVector___bool__)
    __len__ = _swig_new_instance_method(_magneto_cpu.StringVector___len__)
    __getslice__ = _swig_new_instance_method(_magneto_cpu.StringVector___getslice__)
    __setslice__ = _swig_new_instance_method(_magneto_cpu.StringVector___setslice__)
    __delslice__ = _swig_new_instance_method(_magneto_cpu.StringVector___delslice__)
    __delitem__ = _swig_new_instance_method(_magneto_cpu.StringVector___delitem__)
    __getitem__ = _swig_new_instance_method(_magneto_cpu.StringVector___getitem__)
    __setitem__ = _swig_new_instance_method(_magneto_cpu.StringVector___setitem__)
    pop = _swig_new_instance_method(_magneto_cpu.StringVector_pop)
    append = _swig_new_instance_method(_magneto_cpu.StringVector_append)
    empty = _swig_new_instance_method(_magneto_cpu.StringVector_empty)
    size = _swig_new_instance_method(_magneto_cpu.StringVector_size)
    swap = _swig_new_instance_method(_magneto_cpu.StringVector_swap)
    begin = _swig_new_instance_method(_magneto_cpu.StringVector_begin)
    end = _swig_new_instance_method(_magneto_cpu.StringVector_end)
    rbegin = _swig_new_instance_method(_magneto_cpu.StringVector_rbegin)
    rend = _swig_new_instance_method(_magneto_cpu.StringVector_rend)
    clear = _swig_new_instance_method(_magneto_cpu.StringVector_clear)
    get_allocator = _swig_new_instance_method(_magneto_cpu.StringVector_get_allocator)
    pop_back = _swig_new_instance_method(_magneto_cpu.StringVector_pop_back)
    erase = _swig_new_instance_method(_magneto_cpu.StringVector_erase)

    def __init__(self, *args):
        _magneto_cpu.StringVector_swiginit(self, _magneto_cpu.new_StringVector(*args))
    push_back = _swig_new_instance_method(_magneto_cpu.StringVector_push_back)
    front = _swig_new_instance_method(_magneto_cpu.StringVector_front)
    back = _swig_new_instance_method(_magneto_cpu.StringVector_back)
    assign = _swig_new_instance_method(_magneto_cpu.StringVector_assign)
    resize = _swig_new_instance_method(_magneto_cpu.StringVector_resize)
    insert = _swig_new_instance_method(_magneto_cpu.StringVector_insert)
    reserve = _swig_new_instance_method(_magneto_cpu.StringVector_reserve)
    capacity = _swig_new_instance_method(_magneto_cpu.StringVector_capacity)
    __swig_destroy__ = _magneto_cpu.delete_StringVector

# Register StringVector in _magneto_cpu:
_magneto_cpu.StringVector_swigregister(StringVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_magneto_cpu.IntVector_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_magneto_cpu.IntVector___nonzero__)
    __bool__ = _swig_new_instance_method(_magneto_cpu.IntVector___bool__)
    __len__ = _swig_new_instance_method(_magneto_cpu.IntVector___len__)
    __getslice__ = _swig_new_instance_method(_magneto_cpu.IntVector___getslice__)
    __setslice__ = _swig_new_instance_method(_magneto_cpu.IntVector___setslice__)
    __delslice__ = _swig_new_instance_method(_magneto_cpu.IntVector___delslice__)
    __delitem__ = _swig_new_instance_method(_magneto_cpu.IntVector___delitem__)
    __getitem__ = _swig_new_instance_method(_magneto_cpu.IntVector___getitem__)
    __setitem__ = _swig_new_instance_method(_magneto_cpu.IntVector___setitem__)
    pop = _swig_new_instance_method(_magneto_cpu.IntVector_pop)
    append = _swig_new_instance_method(_magneto_cpu.IntVector_append)
    empty = _swig_new_instance_method(_magneto_cpu.IntVector_empty)
    size = _swig_new_instance_method(_magneto_cpu.IntVector_size)
    swap = _swig_new_instance_method(_magneto_cpu.IntVector_swap)
    begin = _swig_new_instance_method(_magneto_cpu.IntVector_begin)
    end = _swig_new_instance_method(_magneto_cpu.IntVector_end)
    rbegin = _swig_new_instance_method(_magneto_cpu.IntVector_rbegin)
    rend = _swig_new_instance_method(_magneto_cpu.IntVector_rend)
    clear = _swig_new_instance_method(_magneto_cpu.IntVector_clear)
    get_allocator = _swig_new_instance_method(_magneto_cpu.IntVector_get_allocator)
    pop_back = _swig_new_instance_method(_magneto_cpu.IntVector_pop_back)
    erase = _swig_new_instance_method(_magneto_cpu.IntVector_erase)

    def __init__(self, *args):
        _magneto_cpu.IntVector_swiginit(self, _magneto_cpu.new_IntVector(*args))
    push_back = _swig_new_instance_method(_magneto_cpu.IntVector_push_back)
    front = _swig_new_instance_method(_magneto_cpu.IntVector_front)
    back = _swig_new_instance_method(_magneto_cpu.IntVector_back)
    assign = _swig_new_instance_method(_magneto_cpu.IntVector_assign)
    resize = _swig_new_instance_method(_magneto_cpu.IntVector_resize)
    insert = _swig_new_instance_method(_magneto_cpu.IntVector_insert)
    reserve = _swig_new_instance_method(_magneto_cpu.IntVector_reserve)
    capacity = _swig_new_instance_method(_magneto_cpu.IntVector_capacity)
    __swig_destroy__ = _magneto_cpu.delete_IntVector

# Register IntVector in _magneto_cpu:
_magneto_cpu.IntVector_swigregister(IntVector)

matty_initialize = _magneto_cpu.matty_initialize
matty_deinitialize = _magneto_cpu.matty_deinitialize
linearInterpolate = _magneto_cpu.linearInterpolate
findExtremum = _magneto_cpu.findExtremum
fftn = _magneto_cpu.fftn
ifftn = _magneto_cpu.ifftn
class Shape(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _magneto_cpu.Shape_swiginit(self, _magneto_cpu.new_Shape(*args))
    __swig_destroy__ = _magneto_cpu.delete_Shape
    getLinIdx = _swig_new_instance_method(_magneto_cpu.Shape_getLinIdx)
    getDim = _swig_new_instance_method(_magneto_cpu.Shape_getDim)
    getDims = _swig_new_instance_method(_magneto_cpu.Shape_getDims)
    getStride = _swig_new_instance_method(_magneto_cpu.Shape_getStride)
    getStrides = _swig_new_instance_method(_magneto_cpu.Shape_getStrides)
    getRank = _swig_new_instance_method(_magneto_cpu.Shape_getRank)
    getNumEl = _swig_new_instance_method(_magneto_cpu.Shape_getNumEl)
    sameDims = _swig_new_instance_method(_magneto_cpu.Shape_sameDims)

# Register Shape in _magneto_cpu:
_magneto_cpu.Shape_swigregister(Shape)

class AbstractMatrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    getShape = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_getShape)
    isUniform = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_isUniform)
    isWriteLocked = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_isWriteLocked)
    isLocked = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_isLocked)
    inspect = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_inspect)
    flush = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_flush)
    dimX = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_dimX)
    dimY = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_dimY)
    dimZ = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_dimZ)
    size = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_size)
    markUninitialized = _swig_new_instance_method(_magneto_cpu.AbstractMatrix_markUninitialized)
    __swig_destroy__ = _magneto_cpu.delete_AbstractMatrix

# Register AbstractMatrix in _magneto_cpu:
_magneto_cpu.AbstractMatrix_swigregister(AbstractMatrix)

class Matrix(AbstractMatrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _magneto_cpu.Matrix_swiginit(self, _magneto_cpu.new_Matrix(*args))
    __swig_destroy__ = _magneto_cpu.delete_Matrix
    swap = _swig_new_instance_method(_magneto_cpu.Matrix_swap)
    clear = _swig_new_instance_method(_magneto_cpu.Matrix_clear)
    fill = _swig_new_instance_method(_magneto_cpu.Matrix_fill)
    assign = _swig_new_instance_method(_magneto_cpu.Matrix_assign)
    scale = _swig_new_instance_method(_magneto_cpu.Matrix_scale)
    add = _swig_new_instance_method(_magneto_cpu.Matrix_add)
    multiply = _swig_new_instance_method(_magneto_cpu.Matrix_multiply)
    divide = _swig_new_instance_method(_magneto_cpu.Matrix_divide)
    randomize = _swig_new_instance_method(_magneto_cpu.Matrix_randomize)
    maximum = _swig_new_instance_method(_magneto_cpu.Matrix_maximum)
    average = _swig_new_instance_method(_magneto_cpu.Matrix_average)
    sum = _swig_new_instance_method(_magneto_cpu.Matrix_sum)
    getUniformValue = _swig_new_instance_method(_magneto_cpu.Matrix_getUniformValue)
    set = _swig_new_instance_method(_magneto_cpu.Matrix_set)
    get = _swig_new_instance_method(_magneto_cpu.Matrix_get)
    toByteArray = _swig_new_instance_method(_magneto_cpu.Matrix_toByteArray)
    fromByteArray = _swig_new_instance_method(_magneto_cpu.Matrix_fromByteArray)

# Register Matrix in _magneto_cpu:
_magneto_cpu.Matrix_swigregister(Matrix)

class VectorMatrix(AbstractMatrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _magneto_cpu.VectorMatrix_swiginit(self, _magneto_cpu.new_VectorMatrix(*args))
    __swig_destroy__ = _magneto_cpu.delete_VectorMatrix
    swap = _swig_new_instance_method(_magneto_cpu.VectorMatrix_swap)
    clear = _swig_new_instance_method(_magneto_cpu.VectorMatrix_clear)
    fill = _swig_new_instance_method(_magneto_cpu.VectorMatrix_fill)
    assign = _swig_new_instance_method(_magneto_cpu.VectorMatrix_assign)
    scale = _swig_new_instance_method(_magneto_cpu.VectorMatrix_scale)
    scale_by_vector = _swig_new_instance_method(_magneto_cpu.VectorMatrix_scale_by_vector)
    multiplyField = _swig_new_instance_method(_magneto_cpu.VectorMatrix_multiplyField)
    add = _swig_new_instance_method(_magneto_cpu.VectorMatrix_add)
    randomize = _swig_new_instance_method(_magneto_cpu.VectorMatrix_randomize)
    normalize = _swig_new_instance_method(_magneto_cpu.VectorMatrix_normalize)
    absMax = _swig_new_instance_method(_magneto_cpu.VectorMatrix_absMax)
    dotSum = _swig_new_instance_method(_magneto_cpu.VectorMatrix_dotSum)
    maximum = _swig_new_instance_method(_magneto_cpu.VectorMatrix_maximum)
    average = _swig_new_instance_method(_magneto_cpu.VectorMatrix_average)
    sum = _swig_new_instance_method(_magneto_cpu.VectorMatrix_sum)
    getUniformValue = _swig_new_instance_method(_magneto_cpu.VectorMatrix_getUniformValue)
    set = _swig_new_instance_method(_magneto_cpu.VectorMatrix_set)
    get = _swig_new_instance_method(_magneto_cpu.VectorMatrix_get)
    toByteArray = _swig_new_instance_method(_magneto_cpu.VectorMatrix_toByteArray)
    fromByteArray = _swig_new_instance_method(_magneto_cpu.VectorMatrix_fromByteArray)

# Register VectorMatrix in _magneto_cpu:
_magneto_cpu.VectorMatrix_swigregister(VectorMatrix)

class ComplexMatrix(AbstractMatrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _magneto_cpu.ComplexMatrix_swiginit(self, _magneto_cpu.new_ComplexMatrix(*args))
    __swig_destroy__ = _magneto_cpu.delete_ComplexMatrix
    clear = _swig_new_instance_method(_magneto_cpu.ComplexMatrix_clear)
    fill = _swig_new_instance_method(_magneto_cpu.ComplexMatrix_fill)
    assign = _swig_new_instance_method(_magneto_cpu.ComplexMatrix_assign)
    getUniformValue = _swig_new_instance_method(_magneto_cpu.ComplexMatrix_getUniformValue)

# Register ComplexMatrix in _magneto_cpu:
_magneto_cpu.ComplexMatrix_swigregister(ComplexMatrix)



def extend():

  def get_shape(self):
    sh = self.getShape()
    return (sh.getDim(0), sh.getDim(1), sh.getDim(2))

  def get_rank(self):
    sh = self.getShape()
    return sh.getRank()

  def get_uniform_value(self):
    if not self.isUniform():
      raise ValueError("VectorMatrix must be uniform in order to access the uniform_value property!")
    return self.getUniformValue()

  def the_repr(self):
     return  "VectorMatrix(%r)" % (self.shape,)

  AbstractMatrix.shape         = property(get_shape)
  AbstractMatrix.rank          = property(get_rank)
  AbstractMatrix.uniform_value = property(get_uniform_value)

  VectorMatrix.element_size    = property(lambda self: 3)
  VectorMatrix.__repr__        = lambda self: "VectorMatrix(%r)" % (self.shape,)

  Matrix.element_size          = property(lambda self: 1)
  Matrix.__repr__              = lambda self: "Matrix(%r)" % (self.shape,)

  ComplexMatrix.__repr__       = lambda self: "ComplexMatrix(%r)" % (self.shape,)
  ComplexMatrix.element_size   = property(lambda self: 3)

  def vector_matrix_to_numpy(self):
# Get raw data
    data = self.toByteArray()

# Convert to numpy array
    try:
      import numpy as np
    except ImportError:
      raise ImportError("numpy library not found!")
    N = np.frombuffer(data, dtype=np.float64, count=3*self.size())
    N.shape = self.shape + (3,)
    N.strides = (N.itemsize * 3, N.itemsize * 3 * self.dimX(), N.itemsize * 3 * self.dimX() * self.dimY(), N.itemsize)
    return N

  def vector_matrix_from_numpy(self, N):
    try:
      import numpy as np
    except ImportError:
      raise ImportError("numpy library not found!")
# error handling - test for shape and data type
    if(N.ndim != 4):
      raise ValueError("VectorField.from_numpy(N): N.ndim must be 4")
    if(N.shape[3] != 3):
      raise ValueError("VectorField.from_numpy(N): N.shape[3] must be 3")
    if(N.shape[:3] != self.shape):
      raise ValueError("VectorField.from_numpy(N): N.shape[:3] must be the same as the VectorField's dimension")
    try:
      N = N.astype(float)
    except:
      raise ValueError('VectorField.from_numpy(N): N must be convertable to float')
    self.fromByteArray(np.swapaxes(N,2,0).flatten().tobytes(order='C'))

  VectorMatrix.to_numpy   = vector_matrix_to_numpy
  VectorMatrix.from_numpy = vector_matrix_from_numpy

  def matrix_to_numpy(self):
# Get raw data
    data = self.toByteArray()

# Convert to numpy array
    try:
      import numpy as np
    except ImportError:
      raise ImportError("numpy library not found!")
    N = np.frombuffer(data, dtype=np.float64, count=self.size())
    N.shape = self.shape
    N.strides = (N.itemsize, N.itemsize * self.dimX(), N.itemsize * self.dimX() * self.dimY())
    return N

  def matrix_from_numpy(self, N):
    try:
      import numpy as np
    except ImportError:
      raise ImportError("numpy library not found!")
# error handling - test for shape and data type
    if(N.shape != self.shape):
      raise ValueError("Field.from_numpy(N): N.shape must be the same as the Field's dimension")
    try:
      N = N.astype(float)
    except:
      raise ValueError("Field.from_numpy(N): N must be convertable to float")
    self.fromByteArray(np.swapaxes(N,2,0).flatten().tobytes(order='C'))

  Matrix.to_numpy   = matrix_to_numpy
  Matrix.from_numpy = matrix_from_numpy

extend()
del extend

matty_initialize()


exchange = _magneto_cpu.exchange
exchange_nnn = _magneto_cpu.exchange_nnn
fs_exchange = _magneto_cpu.fs_exchange
llge = _magneto_cpu.llge
Hmm = _magneto_cpu.Hmm
Hhb = _magneto_cpu.Hhb
PADDING_DISABLE = _magneto_cpu.PADDING_DISABLE
PADDING_ROUND_2 = _magneto_cpu.PADDING_ROUND_2
PADDING_ROUND_4 = _magneto_cpu.PADDING_ROUND_4
PADDING_ROUND_8 = _magneto_cpu.PADDING_ROUND_8
PADDING_ROUND_POT = _magneto_cpu.PADDING_ROUND_POT
PADDING_SMALL_PRIME_FACTORS = _magneto_cpu.PADDING_SMALL_PRIME_FACTORS
GenerateDemagTensor = _magneto_cpu.GenerateDemagTensor
fs_GenerateDemagTensor = _magneto_cpu.fs_GenerateDemagTensor
GeneratePhiDemagTensor = _magneto_cpu.GeneratePhiDemagTensor
INFINITE_NONE = _magneto_cpu.INFINITE_NONE
INFINITE_POS_X = _magneto_cpu.INFINITE_POS_X
INFINITE_NEG_X = _magneto_cpu.INFINITE_NEG_X
INFINITE_POS_Y = _magneto_cpu.INFINITE_POS_Y
INFINITE_NEG_Y = _magneto_cpu.INFINITE_NEG_Y
INFINITE_POS_Z = _magneto_cpu.INFINITE_POS_Z
INFINITE_NEG_Z = _magneto_cpu.INFINITE_NEG_Z
CalculateStrayfieldForCuboid = _magneto_cpu.CalculateStrayfieldForCuboid
uniaxial_anisotropy = _magneto_cpu.uniaxial_anisotropy
cubic_anisotropy = _magneto_cpu.cubic_anisotropy
fs_uniaxial_anisotropy = _magneto_cpu.fs_uniaxial_anisotropy
fs_cubic_anisotropy = _magneto_cpu.fs_cubic_anisotropy
fdm_zhangli = _magneto_cpu.fdm_zhangli
fdm_slonchewski = _magneto_cpu.fdm_slonchewski
OMF_FORMAT_ASCII = _magneto_cpu.OMF_FORMAT_ASCII
OMF_FORMAT_BINARY_4 = _magneto_cpu.OMF_FORMAT_BINARY_4
OMF_FORMAT_BINARY_8 = _magneto_cpu.OMF_FORMAT_BINARY_8
class OMFHeader(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _magneto_cpu.OMFHeader_swiginit(self, _magneto_cpu.new_OMFHeader())
    __swig_destroy__ = _magneto_cpu.delete_OMFHeader
    Title = property(_magneto_cpu.OMFHeader_Title_get, _magneto_cpu.OMFHeader_Title_set)
    Desc = property(_magneto_cpu.OMFHeader_Desc_get, _magneto_cpu.OMFHeader_Desc_set)
    meshunit = property(_magneto_cpu.OMFHeader_meshunit_get, _magneto_cpu.OMFHeader_meshunit_set)
    valueunit = property(_magneto_cpu.OMFHeader_valueunit_get, _magneto_cpu.OMFHeader_valueunit_set)
    valuemultiplier = property(_magneto_cpu.OMFHeader_valuemultiplier_get, _magneto_cpu.OMFHeader_valuemultiplier_set)
    xmin = property(_magneto_cpu.OMFHeader_xmin_get, _magneto_cpu.OMFHeader_xmin_set)
    ymin = property(_magneto_cpu.OMFHeader_ymin_get, _magneto_cpu.OMFHeader_ymin_set)
    zmin = property(_magneto_cpu.OMFHeader_zmin_get, _magneto_cpu.OMFHeader_zmin_set)
    xmax = property(_magneto_cpu.OMFHeader_xmax_get, _magneto_cpu.OMFHeader_xmax_set)
    ymax = property(_magneto_cpu.OMFHeader_ymax_get, _magneto_cpu.OMFHeader_ymax_set)
    zmax = property(_magneto_cpu.OMFHeader_zmax_get, _magneto_cpu.OMFHeader_zmax_set)
    ValueRangeMaxMag = property(_magneto_cpu.OMFHeader_ValueRangeMaxMag_get, _magneto_cpu.OMFHeader_ValueRangeMaxMag_set)
    ValueRangeMinMag = property(_magneto_cpu.OMFHeader_ValueRangeMinMag_get, _magneto_cpu.OMFHeader_ValueRangeMinMag_set)
    meshtype = property(_magneto_cpu.OMFHeader_meshtype_get, _magneto_cpu.OMFHeader_meshtype_set)
    xbase = property(_magneto_cpu.OMFHeader_xbase_get, _magneto_cpu.OMFHeader_xbase_set)
    ybase = property(_magneto_cpu.OMFHeader_ybase_get, _magneto_cpu.OMFHeader_ybase_set)
    zbase = property(_magneto_cpu.OMFHeader_zbase_get, _magneto_cpu.OMFHeader_zbase_set)
    xstepsize = property(_magneto_cpu.OMFHeader_xstepsize_get, _magneto_cpu.OMFHeader_xstepsize_set)
    ystepsize = property(_magneto_cpu.OMFHeader_ystepsize_get, _magneto_cpu.OMFHeader_ystepsize_set)
    zstepsize = property(_magneto_cpu.OMFHeader_zstepsize_get, _magneto_cpu.OMFHeader_zstepsize_set)
    xnodes = property(_magneto_cpu.OMFHeader_xnodes_get, _magneto_cpu.OMFHeader_xnodes_set)
    ynodes = property(_magneto_cpu.OMFHeader_ynodes_get, _magneto_cpu.OMFHeader_ynodes_set)
    znodes = property(_magneto_cpu.OMFHeader_znodes_get, _magneto_cpu.OMFHeader_znodes_set)

# Register OMFHeader in _magneto_cpu:
_magneto_cpu.OMFHeader_swigregister(OMFHeader)

readOMF = _magneto_cpu.readOMF
writeOMF = _magneto_cpu.writeOMF
fs_spinhall = _magneto_cpu.fs_spinhall
fs_fdm_slonchewski = _magneto_cpu.fs_fdm_slonchewski
dmi = _magneto_cpu.dmi
fs_dmi = _magneto_cpu.fs_dmi
interlayerExchange = _magneto_cpu.interlayerExchange
interlayerExchange_multi = _magneto_cpu.interlayerExchange_multi
fdm_temperature = _magneto_cpu.fdm_temperature
fs_fdm_temperature = _magneto_cpu.fs_fdm_temperature
topology_charge_continuous = _magneto_cpu.topology_charge_continuous
topology_charge_density_continuous = _magneto_cpu.topology_charge_density_continuous
topology_charge_berg_luescher_dual_lattice = _magneto_cpu.topology_charge_berg_luescher_dual_lattice
topology_charge_berg_luescher_density_dual_lattice = _magneto_cpu.topology_charge_berg_luescher_density_dual_lattice
topology_charge_berg_luescher = _magneto_cpu.topology_charge_berg_luescher
topology_charge_berg_luescher_density = _magneto_cpu.topology_charge_berg_luescher_density
class AMR(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, dim_x, dim_y, dim_z, delta_x, delta_y, delta_z, arg8, arg9, arg10):
        _magneto_cpu.AMR_swiginit(self, _magneto_cpu.new_AMR(dim_x, dim_y, dim_z, delta_x, delta_y, delta_z, arg8, arg9, arg10))
    __swig_destroy__ = _magneto_cpu.delete_AMR
    calculate = _swig_new_instance_method(_magneto_cpu.AMR_calculate)
    get_j = _swig_new_instance_method(_magneto_cpu.AMR_get_j)
    get_phi = _swig_new_instance_method(_magneto_cpu.AMR_get_phi)
    get_resistance = _swig_new_instance_method(_magneto_cpu.AMR_get_resistance)
    setSigma = _swig_new_instance_method(_magneto_cpu.AMR_setSigma)
    setAMR = _swig_new_instance_method(_magneto_cpu.AMR_setAMR)

# Register AMR in _magneto_cpu:
_magneto_cpu.AMR_swigregister(AMR)

minimize = _magneto_cpu.minimize
class cosinecheck(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    idx_x0 = property(_magneto_cpu.cosinecheck_idx_x0_get, _magneto_cpu.cosinecheck_idx_x0_set)
    idx_y0 = property(_magneto_cpu.cosinecheck_idx_y0_get, _magneto_cpu.cosinecheck_idx_y0_set)
    idx_z0 = property(_magneto_cpu.cosinecheck_idx_z0_get, _magneto_cpu.cosinecheck_idx_z0_set)
    r_0 = property(_magneto_cpu.cosinecheck_r_0_get, _magneto_cpu.cosinecheck_r_0_set)
    r_1 = property(_magneto_cpu.cosinecheck_r_1_get, _magneto_cpu.cosinecheck_r_1_set)
    idx_x1 = property(_magneto_cpu.cosinecheck_idx_x1_get, _magneto_cpu.cosinecheck_idx_x1_set)
    idx_y1 = property(_magneto_cpu.cosinecheck_idx_y1_get, _magneto_cpu.cosinecheck_idx_y1_set)
    idx_z1 = property(_magneto_cpu.cosinecheck_idx_z1_get, _magneto_cpu.cosinecheck_idx_z1_set)
    cos_r = property(_magneto_cpu.cosinecheck_cos_r_get, _magneto_cpu.cosinecheck_cos_r_set)
    cos_u = property(_magneto_cpu.cosinecheck_cos_u_get, _magneto_cpu.cosinecheck_cos_u_set)
    cos_f = property(_magneto_cpu.cosinecheck_cos_f_get, _magneto_cpu.cosinecheck_cos_f_set)

    def __init__(self, dim_x, dim_y, dim_z, M, Ms, treshold):
        _magneto_cpu.cosinecheck_swiginit(self, _magneto_cpu.new_cosinecheck(dim_x, dim_y, dim_z, M, Ms, treshold))
    __swig_destroy__ = _magneto_cpu.delete_cosinecheck

# Register cosinecheck in _magneto_cpu:
_magneto_cpu.cosinecheck_swigregister(cosinecheck)

class SymmetricMatrixVectorConvolution_FFT(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lhs, dim_x, dim_y, dim_z):
        _magneto_cpu.SymmetricMatrixVectorConvolution_FFT_swiginit(self, _magneto_cpu.new_SymmetricMatrixVectorConvolution_FFT(lhs, dim_x, dim_y, dim_z))
    __swig_destroy__ = _magneto_cpu.delete_SymmetricMatrixVectorConvolution_FFT
    execute = _swig_new_instance_method(_magneto_cpu.SymmetricMatrixVectorConvolution_FFT_execute)

# Register SymmetricMatrixVectorConvolution_FFT in _magneto_cpu:
_magneto_cpu.SymmetricMatrixVectorConvolution_FFT_swigregister(SymmetricMatrixVectorConvolution_FFT)

class SymmetricMatrixVectorConvolution_Simple(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lhs, dim_x, dim_y, dim_z):
        _magneto_cpu.SymmetricMatrixVectorConvolution_Simple_swiginit(self, _magneto_cpu.new_SymmetricMatrixVectorConvolution_Simple(lhs, dim_x, dim_y, dim_z))
    __swig_destroy__ = _magneto_cpu.delete_SymmetricMatrixVectorConvolution_Simple
    execute = _swig_new_instance_method(_magneto_cpu.SymmetricMatrixVectorConvolution_Simple_execute)

# Register SymmetricMatrixVectorConvolution_Simple in _magneto_cpu:
_magneto_cpu.SymmetricMatrixVectorConvolution_Simple_swigregister(SymmetricMatrixVectorConvolution_Simple)

class AntisymmetricMatrixVectorConvolution_FFT(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lhs, dim_x, dim_y, dim_z):
        _magneto_cpu.AntisymmetricMatrixVectorConvolution_FFT_swiginit(self, _magneto_cpu.new_AntisymmetricMatrixVectorConvolution_FFT(lhs, dim_x, dim_y, dim_z))
    __swig_destroy__ = _magneto_cpu.delete_AntisymmetricMatrixVectorConvolution_FFT
    execute = _swig_new_instance_method(_magneto_cpu.AntisymmetricMatrixVectorConvolution_FFT_execute)

# Register AntisymmetricMatrixVectorConvolution_FFT in _magneto_cpu:
_magneto_cpu.AntisymmetricMatrixVectorConvolution_FFT_swigregister(AntisymmetricMatrixVectorConvolution_FFT)

class VectorVectorConvolution_FFT(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, lhs, dim_x, dim_y, dim_z, delta_x, delta_y, delta_z):
        _magneto_cpu.VectorVectorConvolution_FFT_swiginit(self, _magneto_cpu.new_VectorVectorConvolution_FFT(lhs, dim_x, dim_y, dim_z, delta_x, delta_y, delta_z))
    __swig_destroy__ = _magneto_cpu.delete_VectorVectorConvolution_FFT
    execute = _swig_new_instance_method(_magneto_cpu.VectorVectorConvolution_FFT_execute)

# Register VectorVectorConvolution_FFT in _magneto_cpu:
_magneto_cpu.VectorVectorConvolution_FFT_swigregister(VectorVectorConvolution_FFT)

gradient = _magneto_cpu.gradient
scaled_abs_max = _magneto_cpu.scaled_abs_max
HAVE_FFTW_THREADS = _magneto_cpu.HAVE_FFTW_THREADS
class ButcherTableau(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, num_steps):
        _magneto_cpu.ButcherTableau_swiginit(self, _magneto_cpu.new_ButcherTableau(num_steps))
    __swig_destroy__ = _magneto_cpu.delete_ButcherTableau
    setA = _swig_new_instance_method(_magneto_cpu.ButcherTableau_setA)
    getA = _swig_new_instance_method(_magneto_cpu.ButcherTableau_getA)
    setB = _swig_new_instance_method(_magneto_cpu.ButcherTableau_setB)
    getB = _swig_new_instance_method(_magneto_cpu.ButcherTableau_getB)
    setC = _swig_new_instance_method(_magneto_cpu.ButcherTableau_setC)
    getC = _swig_new_instance_method(_magneto_cpu.ButcherTableau_getC)
    setEC = _swig_new_instance_method(_magneto_cpu.ButcherTableau_setEC)
    getEC = _swig_new_instance_method(_magneto_cpu.ButcherTableau_getEC)
    getNumSteps = _swig_new_instance_method(_magneto_cpu.ButcherTableau_getNumSteps)

# Register ButcherTableau in _magneto_cpu:
_magneto_cpu.ButcherTableau_swigregister(ButcherTableau)

rk_prepare_step = _magneto_cpu.rk_prepare_step
rk_combine_result = _magneto_cpu.rk_combine_result
rk_adjust_stepsize = _magneto_cpu.rk_adjust_stepsize
getBenchmarkRecord = _magneto_cpu.getBenchmarkRecord
resetBenchmark = _magneto_cpu.resetBenchmark
class RectangularMesh(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _magneto_cpu.RectangularMesh_swiginit(self, _magneto_cpu.new_RectangularMesh(*args))
    isCompatible = _swig_new_instance_method(_magneto_cpu.RectangularMesh_isCompatible)
    getCellVolume = _swig_new_instance_method(_magneto_cpu.RectangularMesh_getCellVolume)
    getTotalNodes = _swig_new_instance_method(_magneto_cpu.RectangularMesh_getTotalNodes)
    getVolume = _swig_new_instance_method(_magneto_cpu.RectangularMesh_getVolume)
    getNumNodes = _swig_new_instance_method(_magneto_cpu.RectangularMesh_getNumNodes)
    getDelta = _swig_new_instance_method(_magneto_cpu.RectangularMesh_getDelta)
    getSize = _swig_new_instance_method(_magneto_cpu.RectangularMesh_getSize)
    getPeriodicBC = _swig_new_instance_method(_magneto_cpu.RectangularMesh_getPeriodicBC)
    getPosition = _swig_new_instance_method(_magneto_cpu.RectangularMesh_getPosition)

    def __repr__(self):
      return "RectangularMesh(%r, %r, periodic_bc=%r, periodic_repeat=%r)" % (self.num_nodes, self.delta, self.periodic_bc[0], self.periodic_bc[1])

    def iterateCellIndices(self):
      """
      Returns iterator that iterates through all cell indices (x,y,z).
      Example:
        for x,y,z in mesh.iterateCellIndices():
          print(x,y,z)
      """
      import itertools
      return itertools.product(*map(range, self.num_nodes))

    __swig_destroy__ = _magneto_cpu.delete_RectangularMesh

# Register RectangularMesh in _magneto_cpu:
_magneto_cpu.RectangularMesh_swigregister(RectangularMesh)



RectangularMesh.volume      = property(                   RectangularMesh.getVolume)
RectangularMesh.cell_volume = property(                   RectangularMesh.getCellVolume)
RectangularMesh.total_nodes = property(                   RectangularMesh.getTotalNodes)
RectangularMesh.num_nodes   = property(lambda self: tuple(RectangularMesh.getNumNodes(self)))
RectangularMesh.delta       = property(lambda self: tuple(RectangularMesh.getDelta(self)))
RectangularMesh.size        = property(lambda self: tuple(RectangularMesh.getSize(self)))
RectangularMesh.periodic_bc = property(lambda self: tuple(RectangularMesh.getPeriodicBC(self)))


class VectorField(VectorMatrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, mesh):
        _magneto_cpu.VectorField_swiginit(self, _magneto_cpu.new_VectorField(mesh))
    __swig_destroy__ = _magneto_cpu.delete_VectorField
    getMesh = _swig_new_instance_method(_magneto_cpu.VectorField_getMesh)


    def __repr__(self):
      return "VectorField(%r)" % self.mesh

    def initFromFunction(self, init_fn):
      mesh = self.mesh
      for idx in range(mesh.total_nodes):
        self.set(idx, init_fn(mesh, mesh.getPosition(idx)))

    def findExtremum(self, z_slice=0, component=0): # TODO: Better name (only the xy-Plane is searched)
      import magnum.magneto as magneto
      cell = magneto.findExtremum(self, z_slice, component)
      return (
        (0.5 + cell[0]) * self.mesh.delta[0],
        (0.5 + cell[1]) * self.mesh.delta[1],
        (0.5 + cell[2]) * self.mesh.delta[2]
      )

    def interpolate(self, mesh):

      import magnum.magneto as magneto
      need_interpolate = (self.mesh.num_nodes != mesh.num_nodes)
      if need_interpolate:
        nx, ny, nz = mesh.num_nodes # new size (in number of cells)
        interp_mat = magneto.linearInterpolate(self, magneto.Shape(nx, ny, nz))
      else:
        interp_mat = self # no need to interpolate..


      result = VectorField(mesh)
      result.assign(interp_mat)
      return result



# Register VectorField in _magneto_cpu:
_magneto_cpu.VectorField_swigregister(VectorField)



VectorField.mesh = property(VectorField.getMesh)


class Field(Matrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, mesh):
        _magneto_cpu.Field_swiginit(self, _magneto_cpu.new_Field(mesh))
    __swig_destroy__ = _magneto_cpu.delete_Field
    getMesh = _swig_new_instance_method(_magneto_cpu.Field_getMesh)


    def __repr__(self):
      return "Field(%r)" % self.mesh

    def interpolate(self, mesh):

      need_interpolate = (self.mesh.num_nodes != mesh.num_nodes)
      if need_interpolate:
        nx, ny, nz = mesh.num_nodes # new size (in number of cells)
        interp_mat = magneto.linearInterpolate(self, magneto.Shape(nx, ny, nz))
      else:
        interp_mat = self # no need to interpolate..


      result = Field(mesh)
      result.assign(interp_mat)
      return result


# Register Field in _magneto_cpu:
_magneto_cpu.Field_swigregister(Field)



Field.mesh = property(Field.getMesh)


initialize = _magneto_cpu.initialize
deinitialize = _magneto_cpu.deinitialize
setDebugCallback = _magneto_cpu.setDebugCallback
callDebugFunction = _magneto_cpu.callDebugFunction
enableProfiling = _magneto_cpu.enableProfiling
isProfilingEnabled = _magneto_cpu.isProfilingEnabled
printProfilingReport = _magneto_cpu.printProfilingReport
CUDA_DISABLED = _magneto_cpu.CUDA_DISABLED
CUDA_32 = _magneto_cpu.CUDA_32
CUDA_64 = _magneto_cpu.CUDA_64
enableCuda = _magneto_cpu.enableCuda
isCudaEnabled = _magneto_cpu.isCudaEnabled
isCuda64Enabled = _magneto_cpu.isCuda64Enabled
haveCudaSupport = _magneto_cpu.haveCudaSupport
cudaSync = _magneto_cpu.cudaSync
haveFFTWThreads = _magneto_cpu.haveFFTWThreads
setFFTWThreads = _magneto_cpu.setFFTWThreads
flush = _magneto_cpu.flush


